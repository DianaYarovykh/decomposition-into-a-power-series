ЗМІСТ
ВСТУП	8
РОЗДІЛ 1 АЛГОРИТМ СУМУВАННЯ	10
1.1 Вивід рекурентної формули розрахунку	10
1.2 Блок-схеми до програмного застосунку	11
РОЗДІЛ 2 ПРОГРАМНА РЕАЛІЗАЦІЯ	21
2.1 Лістинг програми	21
2.2 Опис даних	24
РОЗДІЛ 3 ДОСЛІДЖЕННЯ ЗБІЖНОСТІ РЯДУ ТА ТОЧНОСТІ ОДЕРЖУВАНИХ РЕЗУЛЬТАТІВ ФУНКЦІЇ	28
3.1 Аналіз збіжності ряду	28
3.2 Аналіз точності наближеного обчислення функції	30
ВИСНОВКИ	32
СПИСОК ВИКОРИСТАНИХ ДЖЕРЕЛ:	33

     

ВСТУП
     
     У ході виконання курсової роботи потрібно розробити програмний застосунок для чисельного обчислення значення аналітичної функції шляхом підсумовування наявних значень для цієї функції у степеневому ряді. Виконання курсової роботи передбачає розробку алгоритму та його реалізацію для обчислення наближеного обчислення значення функції через її розклад в степеневий ряд. Взагалі степеневим рядом називається нескінченний ряд, що має вид: []
f(x)=?_(n=0)^???a_n ?(x-c)?^n=a_0+a_1 ?(x-c)?^1+a_2 ?(x-c)?^2+a_3 ?(x-c)?^3+…?
     Де an – коєфіцієнти н-го доданку, с – деяка константа, а х – змінна визначена в деякій області, що містить с. Але на практиці с часто дорівнює 0 і степеневі ряди мають простіший вид:
      f(x)=?_(n=0)^???a_n x^n=a_0+a_1 x+a_2 x^2+a_3 x^3+…?
         Степеневі ряди широко використовуються у дійсному та комплексному аналізі, як ряди Тейлора, а також в комбінаториці, теорії ймовірностей тощо. Для розробки алгоритму для чисельного обчислення значення функції є досить багато методів розробки. Методи розробки алгоритмів – це загальний підхід у інформатиці до реалізації процесу обчислення. Досить пошириними є такі методи: Метод частинних цілей, динамічне програмування, метод сходження, дерева розв'язків, метод відпрацювання назад, програмування з поверненням назад, альфа-бета відсікання, метод гілок і границь тощо.
     Актуальність теми зумовлена оригінальним підходом до реалізації алгоритму та дослідженням найкращих методів реалізації програмного застосунку.
     Мета роботи полягає в дослідженні можливостей програмного забеспечення для реалізації алгоритму обчислення значення функції через її розклад в степеневий ряд. У зв’язку з цим необхідно виконати такі завдання:
 проаналізувати методи розрахунків заданої функції та її степеневого ряду;
 навести вивід рекурентної формули розрахунку n-го члена степеневого ряду, що визначає задану функцію.
 розробити алгоритм виконання програмного застосунку, що розробляється в курсовій роботі.
 розробити програмний застосунок для чисельного обчислення значення аналітичної функції шляхом підсумовування наявних значень для функції у степеневому ряді.
Об'єктом дослідження є функція ?(1+x) та степеневий ряд 1+x/2-(1*x^2)/(2^2+2!)+(1*3*x^3)/(2^3+3!)-(1*3*5*x^4)/(2^4+4!)…, -1<x<1
     

РОЗДІЛ 1 
АЛГОРИТМ СУМУВАННЯ


1.1 Вивід рекурентної формули розрахунку
     Вивід рекурентного множника для функції, у нашому випадку  ?(1+x), полягає у розкладі функції в ряд Тейлора та методами математичних перетворень знайти залежність між наступним та попереднім членом ряду.[1]
     Розкладемо функцію в ряд Тейлора:
      1+x/2-  (1*x^2)/(2^2*2!)+  (1*3*x^3)/(2^3*3!)-(1*3*5*x^4)/(2^4*4!)+…
     
      ?_(n=0)^??((-1)^n (2n)!x^n)/((1-2n)(?n!)?^2 4^n )
     Виводимо рекурентну формулу розрахунку:
      a_n=a_(n-1)?q
     Звідси:
      q=a_n/a_(n-1) =  (((-1)^n (2n)!x^n)/((1-2n)(?n!)?^2 4^n ))/(((-1)^(n-1) (2(n-1))!x^(n-1))/((1-2(n-1))(?(n-1)!)?^2 4^(n-1) ))=(3-2n)x/2n

     Для знаходження суми ряду, будуть додаватися послідовно всі члени рядку до тих пір член ряду не буде меншим за вказану точність.
     

1.2 Блок-схеми до програмного застосунку

Рис.1.2.1 Схема функції main

Рис. 1.2.2 Схема функції print_consol

Рис.1.2.3 продовження схеми функції print_consol

Рис.1.2.4 продовження схеми функції print_consol

Рис.1.2.5 продовження схеми функції print_consol

Рис.1.2.6 схема функції print_file

Рис.1.2.7 продовження схеми функції print_file

Рис. 1.2.8 схема функції rezults
            
Рис.1.2.9 продовження схеми функції rezults

Рис.1.2.10 схема функції calculation
     

РОЗДІЛ 2
ПРОГРАМНА РЕАЛІЗАЦІЯ


2.1 Лістинг програми
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cmath>
#include <fstream>
using namespace std;
/*
Функція обчислює приблизне значення функції за рядом Тейлора-Маклорена, 
підраховує кількість кроків до заданої точності та повертає ці значення
*/
double calculation(double x, double e, int& n, double a)
{
    double q;
    if (n == 1) {
        a = 1 + x / 2;
    }
    if (abs(a) >= e) {
        n++;
        q = ((3 - 2 * n) * x) / (2 * n);
        return a + calculation(x, e, n, a * q);
    }
    else {
        return 0;
    }
}
/*
Функція приймає значення х початку, кінця та крок, задану точність та 
вибір користувача за збереженням результатів у файл або вивід у консоль
*/
void rezults(double x_begin, double x_finish, double x_step, double e, int save)
{
    int n = 1;
    double a = 1;
    //відкриваємо файл для збереження туди даних
    FILE* f = NULL;
    const char* file_name = "D:\\My projects\\атап-2\\Курсовая\\output.txt";
    if (save == 1)
    {
        errno_t error_code = freopen_s(&f, file_name, "w+", stdout);
        if (error_code != 0) {
            cout << "Cannot open file.\n";
        }
    }
    // друкується початок таблиці
    printf("+-----------------------------------------------------------------------------+\n");
    printf("|   x    |    сумма    |   шаг   |  sqrt(1 + x)  |  эпсилон  |   погрешность  |\n");
    printf("+-----------------------------------------------------------------------------+\n");
    // за допомогою циклу друкуються значення
    while (x_begin <= x_finish)
    {
        double func_val = calculation(x_begin, e, n, a);
        printf("|  %4.1f  |  %.7f  |   %.03d   |   %.7lf   |  %.5f  |  %.10f  |\n", x_begin, func_val, n, sqrt(1 + x_begin), e, abs(func_val - sqrt(1 + x_begin)));
        x_begin += x_step;
        n = 1;
    }
    printf("+-----------------------------------------------------------------------------+\n");
    if (save == 1 && f != NULL) {
        fclose(f);
    }
}
//Функція приймає значення х початку та кінця, крок, точність та вибір виводу результатів
void print_consol(double x_begin, double x_finish, double x_step, double e, int save)
{
    setlocale(LC_ALL, "Russian");
    //цикли в цій функції перевіряють правильність вводу значень
    cout << "Введите начало диапазона: ";
    cin >> x_begin;
    while (x_begin < -1) {
        cout << "Введите начало диапазона > -1 : ";
        cin >> x_begin;
    }
    cout << "Введите конец диапазона: ";
    cin >> x_finish;
    while (x_begin > x_finish || x_finish > 1) {
        cout << "Введите конец диапазона < 1 : ";
        cin >> x_finish;
    }
    cout << "Введите шаг: ";
    cin >> x_step;
    while (x_step == 0) {
        cout << "Введите шаг != 0 : ";
        cin >> x_step;
    }
    cout << "Введите точность: ";
    cin >> e;
    while (e > 1 || e <= 0) {
        cout << "Введите точность (0;1) : ";
        cin >> e;
    }
    cout << "Сохранить данные в файл? Введите 1, если да: ";
    cin >> save;
    rezults(x_begin, x_finish, x_step, e, save);
}
//Функція зчитує з файлу значення х початку та кінця, крок, точність та вибір виводу результатів
void print_file(double& x_begin, double& x_finish, double& x_step, double& e, int save)
{
    setlocale(LC_ALL, "Russian");
    FILE* f = NULL;
    f = fopen("D:\\My projects\\атап-2\\Курсовая\\input.txt", "r");
    if (f != NULL) // якщо файл існує
    {
        fscanf(f, "%lf %lf %lf %lf", &x_begin, &x_finish, &x_step, &e);
        cout << "Начало диапазона: " << x_begin << endl;
        cout << "Конец диапазона: " << x_finish << endl;
        cout << "Шаг: " << x_step << endl;
        cout << "Точность: " << e << endl;
    }
    else // якщо файл відсутній
    {
        cout << "Введите значения с консоли" << endl;
        print_consol(x_begin, x_finish, x_step, e, save);
    }
    fclose(f);
    cout << "Сохранить данные в файл? Введите 1, если да: ";
    cin >> save;
    rezults(x_begin, x_finish, x_step, e, save);
}

int main()
{
    setlocale(LC_ALL, "Russian");
    double x_begin = 0, x_finish = 0, x_step = 0, e = 0;
    int a;
    int save = 0;
    // початок діалогу з користувачем
    do {
        cout << "Использовать консоль или файл?" << endl;
        cout << "Ведите 1 (использовать консоль) или 2 (использовать файл): ";
        cin >> a;
        switch (a)
        {
        case 1:
            print_consol(x_begin, x_finish, x_step, e, save);
            break;
        case 2:
            print_file(x_begin, x_finish, x_step, e, save);
            break;
        default:
            cout << "Введите 1 или 2!" << endl;
            break;
        }
    } while (a != 1 && a != 2); // перевіряє правильність вводу значень
}
       2.2 Опис даних
     На початку роботи програми на консоль виводиться повідомлення про два варіанти вибору вводу даних: 1 – за допомогою консолі, 2 – за допомогою зчитування даних з файлу (рис.2.1)
     
Рис. 2.1 вибір вводу даних
     
     Якщо користувач обрав варіант вводу з консолі, то програма допоможе ввести значення у правильному порядку, також перевірить правильність вводу значень, оскільки функція ?(1+x) приймає значення (-1;1), де -1 і 1 не включені до цього діапазону, перевіряє заданий крок, щоб він не дорівнював 0 і перевіряє вказану точність, яка не повинна перевищувати 1(рис.2.2-2.3).[2]

Рис. 2.2 приклад вводу значень


Рис 2.3 приклад вводу не вірних значень і підказки програми ввести потрібні значення
     
     Далі програма запитує куди виводити результати, якщо користувач вводить 1, то програма виводить таблицю у файл (рис.2.5), а якщо користувач ввів інше значення, то таблиця з результатами виводиться у консоль(рис.2.4).[3]
     
Рис 2.4 вивід результатів у консоль
     
     
Рис 2.5 вивід результатів у текстовий файл
     Якщо користувач хоче використовувати файл для зчитування значень з нього, то при першому повідомленні програми він має обрати 2 – використовувати файл. Дані у файлі мають виглядати наступним чином (рис.2.6)
     
Рис 2.6 вигляд запису даних у файлі для їх зчитування
     
     Далі програма виводить значення, які зчитала з файлу і запитує куди виводити результати обчислення (рис.2.7) [4]
     
Рис 2.7 вивід зчитаних даних з файлу
     

РОЗДІЛ 3
ДОСЛІДЖЕННЯ ЗБІЖНОСТІ РЯДУ ТА ТОЧНОСТІ ОДЕРЖУВАНИХ РЕЗУЛЬТАТІВ ФУНКЦІЇ
     
     
3.1 Аналіз збіжності ряду
      Таблиця 3.1.1
     Кількість членів для досягнення заданої точності
х
сума
крок
функція
похибка
-0.9
0,8356518
46
0,3162278
0,5194240289
-0.6
0,8575917
15
0,6324555
0,2251361532
-0.3
0,9255867
8
0,8366600
0,0889266526
0
1,0000000
2
1,0000000
0,0000000000
0.3
1,0746835
8
1,1401754
0,0654918933
0.6
1,1479515
16
1,2649111
0,1169595499
0.9
1,2192998
53
1,3784049
0,1591050321
     
Рис. 3.1.1 Графік кількості членів для обчислення суми ряду на проміжку [-0,9;0,9]
      Таблиця 3.1.2
х
сума
крок
функція
точність
похибка
-0,9
0,8356518
46
0,3162278
0,00001
0,5194240289
-0,8
0,8291389
26
0,4472136
0,00001
0,3819252620
-0,7
0,8399227
19
0,5477226
0,00001
0,2922001493
-0,6
0,8575917
15
0,6324555
0,00001
0,2251361532
-0,5
0,8786704
12
0,7071068
0,00001
0,1715636216
-0,4
0,9016074
10
0,7745967
0,00001
0,1270106908
-0,3
0,9255867
8
0,8366600
0,00001
0,0889266526
-0,2
0,9501531
7
0,8944272
0,00001
0,0557258715
-0,1
0,9750117
5
0,9486833
0,00001
0,0263284207
0
1,0000000
2
1,0000000
0,00001
0,0000000000
0,1
1,0249805
5
1,0488088
0,00001
0,0238283794
0,2
1,0498943
7
1,0954451
0,00001
0,0455508025
0,3
1,0746835
8
1,1401754
0,00001
0,0654918933
0,4
1,0993001
10
1,1832160
0,00001
0,0839158766
0,5
1,1237303
12
1,2247449
0,00001
0,1010145779
0,6
1,1479515
16
1,2649111
0,00001
0,1169595499
0,7
1,1719621
20
1,3038405
0,00001
0,1318783403
0,8
1,1957371
29
1,3416408
0,00001
0,1459036673
0,9
1,2192998
53
1,3784049
0,00001
0,1591050321
      
     
Рис. 3.1.2 Графік залежності значень х та кількості кроків при точності 0,00001
 на проміжку [-0,9;0,9] з кроком 0,1
     Аналізуючи графік, можна сказати, що при віддаленні значення х від 0, збільшується кількість кроків. Найстрімкіше ця кількість зростає при наближенні до значень -0.7 та 0.7, а також при наближенні до 0.
3.2 Аналіз точності наближеного обчислення функції
     Для проведення аналізу точності ряду потрібно побудувати графіки значень ряду та функції на проміжку [-0,9;0,9].
       
Рис. 3.2.1 Графіки функцій, де фіолетовий графік – значення ряду , а червоний – значення функції з точністю 0,00001 на проміжку [-0,9;0,9] та з кроком 0,1

Рис.3.2.2 Графік значень похибки на проміжку [-0,9;0,9] з точністю 0,00001
      

ВИСНОВКИ

     
     Під час виконання курсової роботи було реалізовано програмний застосунок для чисельного обчислення значення аналітичної функції шляхом підсумовування наявних значень для функції ?(1+x) у степеневому ряду. Одержаний у результаті програмний застосунок забезпечує обчислення значення функції та дозволяє виконання обчислюваного експерименту для дослідження швидкості збіжності ряду і точності одержуваних результатів.
     Для реалізації програмного застосунку була виведена рекурентна формула, яка дозволяє визначення кожного нового члена ряду. Перш за все було реалізовано діалог з користувачем, який дозволяє проводити обчислення на заданому користувачем діапазоні та точності. Результат для зручності сприйняття виводиться у формі таблиці або на консоль, або у текстовий файл за вибором користувача. За допомогою визначених результатів було побудовано графіки точності та кількості необхідних членів ряду для досягнення заданої точності. 
     Загалом всі завдання даної роботи були виконанні та проаналізовані, мета роботи, яка була визначена на її початку була досягнена, разом з нею були набуті корисні навички в програмуванні на мові високого рівня «С++», розвинення аналітично-критичного мислення та поглибилися знання в області рядів та математичного аналізу.
     

СПИСОК ВИКОРИСТАНИХ ДЖЕРЕЛ:


 Ряди. Теорія функцій комплексної змінної. Операційне числення. Практикум. (ІІ курс ІІІ семестр) / Уклад.: І. В. Алєксєєва, В. О. Гайдей, О. О. Диховичний, Л. Б. Федорова. — К: НТУУ «КПІ», 2013. — 160 с.
 Алгоритмізація та програмування мовою високого рівня С++ : комп’ютерний практикум / С. М. Алхімова. - Київ : КШ ім. Ігоря Сікорського, Вид-во Політехніка», 2018. - 156 с.
 Программирование: принципы и практика использования C++,  Страуструп Бьярне. испр. изд. : Пер. с англ. — М. : ООО “И.Д. Вильямс”, 2011. — 1248 с
 Вікіпедія. Методи розробки алгоритмів. Отримано з: https://uk.wikipedia.org/wiki/Методи_розробки_алгоритмів 
      

21


